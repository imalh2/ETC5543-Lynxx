---
title: "South Rd Analysis"
author: "Ibrahim Al-Hindi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r libraries}
# Libraries
library(tidyverse)
library(here)
library(lubridate)
library(leaflet)
library(hms)
library(janitor)
library(geosphere)
```

```{r data}
# Data
links_raw <- read_csv(here("data/addinsight/addinsight_prod.btlinks.csv.csv"))
links_segment_raw <- read_csv(here("data/South-Rd/BT Links - South Rd.csv"))
full_stops_raw <- read_csv(here("data/GTFS_feed_version_1157/large/gtfs_history_prod.stops.csv"))
routes_trips_stops_raw <- read_csv(here("data/South-Rd/South Rd Routes and Trips gtfs 1157.csv"))
updates_raw <- read_csv(here("data/South-Rd/trip_updates_SouthRd_Mar.csv"))
link_stats_raw <- read_csv(here("data/South-Rd/link_5minstats_Mar.csv"))
holidays_raw <- read_csv(here("data/addinsight/addinsight_prod.btspecialdays.csv.csv"))
```

# Data Wrangling and Exploration

## Holidays

```{r}
holidays <- unique(holidays_raw$date)

rm(holidays_raw)
```

## Links Segment

```{r}
links <- links_raw %>%
  filter(date(dms_update_ts) < "2022-04-01") %>% 
  # Get most recent update per link
  group_by(id) %>% 
  filter(dms_update_ts == max(dms_update_ts)) %>% 
  ungroup() %>% 
  select(id, originid:isfreeway) %>% 
  distinct()

links_segment <- links_segment_raw %>% 
  rename_with(tolower) %>% 
  mutate(latitude = round(latitude, 5),
         longitude = round(longitude, 5),
         # Extract name of location where link starts and ends
         start_loc = str_extract(name, "(?<=- ).*(?= to)"),
         end_loc = str_extract(name, "(?<=to ).*")) %>%
  # Add start and end longitudes for each link and whether link going to or from city
  group_by(linkid) %>%
  mutate(start_lat = first(latitude, order_by = ordernumber),
         end_lat = last(latitude, order_by = ordernumber)) %>% 
  ungroup() %>% 
  mutate(direction = if_else(start_lat < end_lat, "to_city", "from_city"),
         direction = factor(direction, levels = c("to_city", "from_city"))) %>%
  # Length is not correct, join with links to get correct lengths
  select(-length) %>% 
  left_join(links, c("linkid" = "id"))

links_segment_unq <- links_segment %>% 
  arrange(linkid, ordernumber) %>% 
  distinct(linkid, .keep_all = TRUE)

rm(links_raw)
rm(links_segment_raw)
```

## Full Stops and Route-Trips-Stops

```{r}
routes_trips_stops <- clean_names(routes_trips_stops_raw)

stops_segment <- full_stops_raw %>% 
  semi_join(routes_trips_stops, by = c("stop_id" = "stop_id_gtfs_history_prod_stops_csv")) %>% 
  select(stop_id, stop_name, stop_desc, stop_lat, stop_lon) %>% 
  distinct(stop_id, .keep_all = TRUE) %>% 
  # If stop is on East side, that means trip going down, and vice versa
  mutate(direction = if_else(str_detect(stop_name, "East"), "from_city", "to_city"),
         direction = factor(direction, levels = c("to_city", "from_city")))

rm(full_stops_raw)
```

## Updates

```{r}
updates <- updates_raw %>%
  rename(trip_id = id,
         vehicle_id = label) %>% 
  mutate(start_date = ymd(start_date),
         timestamp = as_datetime(timestamp, tz = "Australia/Adelaide"),
         arrival_time = as_datetime(arrival_time, tz = "Australia/Adelaide")) %>%
  # Only segment stops and get direction
  inner_join(select(stops_segment, stop_id, direction), by = "stop_id") %>% 
  # Remove weekends and public holidays
  filter(!start_date %in% holidays,
         !wday(start_date, label = TRUE) %in% c("Sat", "Sun")) %>%
  group_by(start_date, trip_id) %>%
  # To join later with first and last stop pairs on segment
  mutate(first_stop = first(stop_id, order_by = stop_sequence),
         last_stop = last(stop_id, order_by = stop_sequence)) %>%
  ungroup()

# Take top occurring stops pair for each direction according to cumsum plot
top_first_last_stops <- updates %>% 
  distinct(start_date, trip_id, direction, first_stop, last_stop) %>%
  group_by(direction) %>% 
  count(first_stop, last_stop, sort = TRUE) %>% 
  slice_max(order_by = n) %>% 
  ungroup()

updates_stop_times <- updates %>% 
  # Keep updates for trips that have first and last stop from pairs identified
  semi_join(top_first_last_stops, by = c("direction", "first_stop", "last_stop")) %>%
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  # Remove trips where all the stops have a delay over 4000, ie entire trip is delayed.
  # Most likely error due to entering the information later. This is done to prevent
  # incorrectly influencing time aggregated figures since they're going to be in
  # the wrong time aggregate
  filter(!(all(delay > 4000))) %>%
  # Remove one-off large jumps in between two observations
  filter(!(delay - lag(delay, order_by = stop_sequence, default = 0) > 1000 &
             delay - lead(delay, order_by = stop_sequence, default = 0) > 1000)) %>%
  # Remove any observations that have an arrival_time later than any following
  # arrival_time in the trip AND the timestamp is earlier than any following timestamps in the trip.
  # This ensures the most recent timestamp is preferred when discrepancy occurs
  filter(!(as.numeric(arrival_time) > order_by(-stop_sequence, cummin(as.numeric(arrival_time))) &
             as.numeric(timestamp) == order_by(-stop_sequence, cummin(as.numeric(timestamp))))) %>%
  # Remove if the arrival_time is less than the previous arrival_times AND the timestamp
  # is older than the previous timestamps
  filter(!(arrival_time < order_by(stop_sequence, cummax(as.numeric(arrival_time))) &
             timestamp < order_by(stop_sequence, cummax(as.numeric(timestamp))))) %>%
  # If arrival_time of a stop is less than prior stops but they all have the same
  # timestamp, it's not possible to know which is correct. Assume earlier stop_sequence
  # is correct since it is closer when the update is made
  filter(!(timestamp == order_by(stop_sequence, cummax(as.numeric(timestamp))) &
           arrival_time < order_by(stop_sequence, cummax(as.numeric(arrival_time))))) %>%
  # If after the above two consecutive stops have the same arrival_time, remove
  # the one with an older timestamp
  filter(!(arrival_time == lead(arrival_time, order_by = stop_sequence,
                                default = ymd("9999-01-01", tz = "UTC")) &
           timestamp < lead(timestamp, order_by = stop_sequence,
                            default = ymd("9999-01-01", tz = "UTC")))) %>%
  # If two stops have the same arrival_time and same time_stamp, remove the one
  # with a higher stop sequence. Make sure only 2 stops and not more
  filter(!(arrival_time != lead(arrival_time, order_by = stop_sequence,
                                default = ymd("9999-01-01", tz = "UTC")) &
             arrival_time == lag(arrival_time, order_by = stop_sequence,
                                 default = ymd("0000-01-01", tz = "UTC")) &
           timestamp == lag(timestamp, order_by = stop_sequence,
                            default = ymd("0000-01-01", tz = "UTC")))) %>%
  # Remove trips with multiple repeating arrival_times
  filter(!n_distinct(arrival_time) < n()) %>%
  mutate(#prior_stamp = lag(timestamp),
         #prior_arrival = lag(arrival_time),
         #post_arrival = lead(arrival_time),
         to_stop_time = as.numeric(arrival_time - lag(arrival_time), units = "secs"),
         # Reidetify first and last stops per trip
         first_stop = first(stop_id, order_by = stop_sequence),
         last_stop = last(stop_id, order_by = stop_sequence)) %>% 
         #delay_diff = delay - lag(delay, default = 0)) %>% 
         #prior_stop_time = lag(to_stop_time, default = 0)) %>% 
         #post_stop_time = lead(to_stop_time, default = 0),) %>%
  ungroup() %>%
  mutate(to_stop_time = replace_na(to_stop_time, 0))
         #prior_stop_time = replace_na(prior_stop_time, 0))
         #post_stop_time = replace_na(post_stop_time, 0)) %>%

# Rejoin to only stops pairs identified again due to possible removal in filtering above
updates_stop_times <- updates_stop_times %>% 
   semi_join(top_first_last_stops, by = c("direction", "first_stop", "last_stop"))

updates_trip_time <- updates_stop_times %>% 
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  mutate(trip_time = as.numeric((last(arrival_time) -
                                   first(arrival_time)), 
                                units = "secs"),
         # Difference between delays of first and last stops of the trip
         delay_diff = abs(last(delay) - first(delay))) %>% 
  ungroup() %>%
  # If the delay_diff is greater than 10 minutes, most likely an error
  filter(delay_diff < 600) %>% 
  arrange(start_date, trip_id, stop_sequence)

# One row per trip corresponding to highest delay in the trip
trip_time_delay <- updates_trip_time %>% 
  group_by(start_date, trip_id) %>% 
  filter(abs(delay) == max(abs(delay))) %>%
  ungroup() %>% 
  distinct(start_date, trip_id, .keep_all = TRUE)

# One row per trip corresponding to highest to_stop_time in the trip
trip_time_stop <- updates_trip_time %>% 
  group_by(start_date, trip_id) %>% 
  filter(abs(to_stop_time) == max(abs(to_stop_time))) %>%
  ungroup() %>% 
  distinct(start_date, trip_id, .keep_all = TRUE)

# For further analysis, take first stop only from each trip because the arrival_time
# of the first stop will be used as the basis for aggregation. Also add whether
# each trip occurrs during in either of the peak times
trip_times <- updates_trip_time %>% 
  group_by(start_date, trip_id) %>% 
  filter(stop_sequence == first(stop_sequence, order_by = stop_sequence)) %>%
  ungroup() %>% 
  distinct(start_date, trip_id, .keep_all = TRUE) %>% 
  mutate(rush = case_when(
    as_hms("06:00:00") <= as_hms(arrival_time) & as_hms(arrival_time) < as_hms("10:00:00") ~ "morning",
    as_hms("15:00:00") <= as_hms(arrival_time) & as_hms(arrival_time) < as_hms("19:00:00") ~ "evening",
    TRUE ~ "neither"),
    rush = factor(rush, levels = c("morning", "evening", "neither"))
  )

trip_times_peaks <- trip_times %>% 
  filter(rush %in% c("morning", "evening"))

# Join with trip_time_delay to only have trips analysed
stop_times <- updates_stop_times %>% 
  semi_join(trip_times, by = c("start_date", "trip_id"))

# Update stops_segment to only stops needed
stops_segment <- stops_segment %>% 
  filter(stop_id %in% c(top_first_last_stops$first_stop, top_first_last_stops$last_stop))

rm(updates_raw)
```

## Data Validation

```{r}
ggplot(updates_stop_times, aes(to_stop_time)) +
  geom_histogram() +
  theme_minimal()

ggplot(updates_stop_times, aes(to_stop_time)) +
  geom_boxplot() +
  theme_minimal()

ggplot(updates_stop_times, aes(delay)) +
  geom_histogram() +
  theme_minimal()

ggplot(updates_stop_times, aes(delay)) +
  geom_boxplot() +
  theme_minimal()

ggplot(updates_stop_times, aes(to_stop_time, delay)) +
  geom_point() +
  theme_minimal()

ggplot(updates_trip_time, aes(trip_time)) +
  geom_histogram() +
  theme_minimal()

ggplot(updates_trip_time, aes(trip_time)) +
  geom_boxplot() +
  theme_minimal()

ggplot(trip_time_delay, aes(trip_time, delay)) +
  geom_point() +
  facet_wrap(vars(direction)) +
  theme_minimal()

ggplot(trip_time_stop, aes(trip_time, to_stop_time)) +
  geom_point() +
  facet_wrap(vars(direction)) +
  theme_minimal()

ggplot(trip_time_delay, aes(trip_time, delay_diff)) +
  geom_point() +
  facet_wrap(vars(direction)) +
  theme_minimal()

ggplot(trip_time_delay, aes(delay_diff, color = direction)) +
  geom_boxplot()

ggplot(trip_time_delay, aes(trip_time, delay_diff, color = direction)) +
  geom_point() +
  theme_minimal()

ggplot(trip_time_stop, aes(trip_time, to_stop_time, color = direction)) +
  geom_point() +
  theme_minimal()

ggplot(stop_times, aes(to_stop_time)) +
  geom_histogram() +
  theme_minimal()

ggplot(stop_times, aes(to_stop_time)) +
  geom_boxplot() +
  theme_minimal()

ggplot(stop_times, aes(delay)) +
  geom_histogram() +
  theme_minimal()

ggplot(stop_times, aes(delay)) +
  geom_boxplot() +
  theme_minimal()

ggplot(stop_times, aes(to_stop_time, delay)) +
  geom_point() +
  theme_minimal()

ggplot(trip_times_peaks, aes(direction, trip_time)) +
  geom_boxplot() +
  facet_wrap(vars(rush)) +
  theme_minimal()

ggplot(trip_times_peaks, aes(trip_time, color = direction)) +
  geom_density() +
  facet_wrap(vars(rush)) +
  theme_minimal()
```

# Getting Information for Analysis

## Identify Routes

Routes were identified by examining the [network map](https://www.adelaidemetro.com.au/__data/assets/pdf_file/0009/824247/Adelaide-Metro-network-map.pdf).

All the routes were overlayed on a map on Tableu and routs on South Road were selected and exported.

## Identify Stops

Same as above

```{r}
# Plot on map to check the stops are all on South Rd
stops_segment %>%
    leaflet() %>% 
    addTiles() %>% 
    addCircles(lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id)
```

## Identify Links

### To city

```{r}
# The going back and forth between links_to_city process is for the purpose of
# producing links_disabled 

linkids_to_city <- links_segment_unq %>%
  filter(direction == "to_city") %>% 
  # Build map from lower end of map to upper
  arrange(start_lat)

# Start and end at same locations as bus stops, in this case Walsh Ave and Anzac Hwy
linkids_to_city <- linkids_to_city[which(tolower(linkids_to_city$start_loc) == "walsh ave"):
                                       which(tolower(linkids_to_city$end_loc) == "anzac hwy"),] %>% 
  # Remove links where end_loc does not have a matching start_loc in another link
  filter(end_loc %in% c(start_loc, end_loc[length(end_loc)])) %>%
  # If more than one link has the same start_loc, pick the shorter one
  group_by(start_loc) %>% 
  filter(length == min(length)) %>% 
  ungroup() %>% 
  pull(linkid)
  
links_to_city <- links_segment_unq %>%
  filter(direction == "to_city") %>% 
  arrange(start_lat) %>%
  mutate(in_route = linkid %in% linkids_to_city)

links_disabled <- tibble(linkid = numeric(),
                         prior_linkid = numeric(),
                         post_linkid = numeric(),
                         direction = character())

for (i in 1:nrow(links_to_city)) {
  if(links_to_city$in_route[i] == TRUE && links_to_city$enabled[i] == FALSE) {
    
    # Retrive last prior link that is enabled
    prior_linkid <- links_to_city[1:i-1,] %>% 
      filter(enabled) %>% 
      slice_tail() %>% 
      pull(linkid)
    
    # Retrive first proceeding link that is enabled
    post_linkid <- links_to_city[i+1:nrow(links_to_city),] %>% 
      filter(enabled) %>% 
      slice_head() %>% 
      pull(linkid)
    
    links_disabled <- links_disabled %>%
      add_row(linkid = links_to_city$linkid[i],
              prior_linkid = prior_linkid,
              post_linkid = post_linkid,
              direction = "to_city")
  }
}

links_to_city <- links_to_city %>% 
  filter(in_route)

# Obtain shape for each link
links_to_city_map <- links_segment %>% 
  filter(linkid %in% linkids_to_city) %>% 
  arrange(start_lat, ordernumber)

links_colors <- c("green","yellow")

n <- 1

map_to_city <- leaflet() %>% 
  addTiles()

# Iterate over links to add polyline of each link to the map
for (link in linkids_to_city) {
  map_df <- links_to_city_map %>% 
    filter(linkid == link)
  
  map_to_city <- map_to_city %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = links_colors[n],
                 label = ~linkid, opacity = 0.3)
  
  # Switch colors
  if (n == 1) {
    n <- 2
  } else {
    n <- 1
  }
}

map_to_city
```

### From city

```{r}
linkids_from_city <- links_segment_unq %>%
  filter(direction == "from_city") %>% 
  arrange(-start_lat)

linkids_from_city <- linkids_from_city[which(tolower(linkids_from_city$start_loc) == "anzac hwy"):
                                         which(tolower(linkids_from_city$end_loc) == "walsh ave"),] %>%
  filter(end_loc %in% c(start_loc, end_loc[length(end_loc)])) %>%
  group_by(start_loc) %>% 
  filter(length == min(length)) %>% 
  ungroup() %>% 
  pull(linkid)
  
links_from_city <- links_segment_unq %>%
  filter(direction == "from_city") %>% 
  arrange(-start_lat) %>%
  mutate(in_route = linkid %in% linkids_from_city)

for (i in 1:nrow(links_from_city)) {
  if(links_from_city$in_route[i] == TRUE && links_from_city$enabled[i] == FALSE) {
    
    prior_linkid <- links_from_city[1:i-1,] %>% 
      filter(enabled) %>% 
      slice_tail() %>% 
      pull(linkid)
    
    post_linkid <- links_from_city[i+1:nrow(links_from_city),] %>% 
      filter(enabled) %>% 
      slice_head() %>% 
      pull(linkid)
    
    links_disabled <- links_disabled %>%
      add_row(linkid = links_from_city$linkid[i],
              prior_linkid = prior_linkid,
              post_linkid = post_linkid,
              direction = "from_city")
  }
}

links_from_city <- links_from_city %>% 
  filter(in_route)

links_from_city_map <- links_segment %>% 
  filter(linkid %in% linkids_from_city) %>% 
  arrange(-start_lat, ordernumber)

links_colors <- c("green","yellow")

n <- 1

map_from_city <- leaflet() %>% 
  addTiles()

for (link in linkids_from_city) {
  map_df <- links_from_city_map %>% 
    filter(linkid == link)
  
  map_from_city <- map_from_city %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = links_colors[n],
                 label = ~linkid, opacity = 0.3)
  
  if (n == 1) {
    n <- 2
  } else {
    n <- 1
  }
}

map_from_city
```

### Both directions together

```{r}
# Plot links from both directions
map_both <- leaflet() %>% 
  addTiles()

# Add links up map
for (link in unique(links_to_city_map$linkid)) {
  map_df <- links_to_city_map %>% 
    filter(linkid == link)
  
  map_both <- map_both %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "green", opacity = 0.3, label = ~linkid)
}

# Add links down map
for (link in unique(links_from_city_map$linkid)) {
  map_df <- links_from_city_map %>% 
    filter(linkid == link)
  
  map_both <- map_both %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red", opacity = 0.3, label = ~linkid)
}

map_both

# Save linkid's for both directions and extra links needed to impute missing links
links_both <- c(linkids_to_city, linkids_from_city, links_disabled$prior_linkid, links_disabled$post_linkid)
```

### Link Stats

```{r}
link_stats <- link_stats_raw %>% 
  select(logtime:avgdensity) %>%
  mutate(logtime = ymd_hms(str_remove(logtime, " \\+10:30"), tz = "Australia/Adelaide")) %>%
  filter(!as_date(logtime) %in% holidays,
         !wday(logtime, label = TRUE) %in% c("Sat", "Sun")) %>% 
  distinct()

# Join link_stats with links_segment to get direction and length
link_stats <- link_stats %>% 
  left_join(select(links_segment_unq, linkid, direction, length)) %>% 
  # Calculate speed
  mutate(speed = round((length/1000) / (tt/3600))) %>%
  # Remove speeds over 150 km/h as most likely errors
  filter(speed < 150)

rm(link_stats_raw)

summary(link_stats)
```

#### Data Validation

```{r}
ggplot(link_stats, aes(tt)) +
  geom_histogram()

ggplot(link_stats, aes(tt)) +
  geom_boxplot()

ggplot(link_stats, aes(speed)) +
  geom_histogram()

ggplot(link_stats, aes(speed)) +
  geom_boxplot()

ggplot(link_stats, aes(factor(length), tt)) +
  geom_boxplot()

ggplot(link_stats, aes(speed, tt)) +
  geom_point()

ggplot(link_stats, aes(factor(length), speed)) +
  geom_boxplot()
```

### Check for links with no stats

```{r}
sort(setdiff(links_both, link_stats$linkid))

links_with_stats <- links_segment %>% 
  semi_join(link_stats, by = "linkid")

links_no_stats <- links_segment %>% 
  filter(linkid %in% links_both) %>% 
  anti_join(link_stats, by = "linkid")
  
map_links_with_stats <- leaflet() %>% 
  addTiles()

for (link in unique(links_with_stats$linkid)) {
  map_df <- links_with_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "yellow", opacity = 1, label = ~linkid)
}

for (link in unique(links_no_stats$linkid)) {
  map_df <- links_no_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red", opacity = 1, label = ~linkid)
}

map_links_with_stats
```

### Generate stats for missing links

This will be done by taking the average time/distance between the prior and post links per aggregate time, then multiplying by the distance of the missing links to get the estimated time on that link

```{r}
for(i in 1:nrow(links_disabled)) {
  link_length <- links %>% 
    filter(id == links_disabled$linkid[i]) %>% 
    pull(length)
  
  link_estimates <- link_stats %>% 
  filter(linkid %in% c(links_disabled$prior_linkid[i], links_disabled$post_linkid[i])) %>% 
  mutate(time_len = tt/length) %>% 
  group_by(logtime) %>% 
  summarise(avg_time_len = mean(time_len),
            direction = unique(direction)) %>% 
  ungroup() %>% 
  mutate(linkid = links_disabled$linkid[i],
         tt = round(avg_time_len * link_length),
         length = link_length) %>% 
  select(-avg_time_len)
  
  link_stats <- link_stats %>% 
  full_join(link_estimates, by = names(link_estimates))
}

links_both <- c(linkids_to_city, linkids_from_city)

# Remove estimator links
link_stats <- link_stats %>% 
  filter(linkid %in% links_both)
```

Check

```{r}
sort(setdiff(links_both, link_stats$linkid))

links_with_stats <- links_segment %>% 
  semi_join(link_stats, by = "linkid")

links_no_stats <- links_segment %>% 
  filter(linkid %in% links_both) %>% 
  anti_join(link_stats, by = "linkid")
  
map_links_with_stats <- leaflet() %>% 
  addTiles()

for (link in unique(links_with_stats$linkid)) {
  map_df <- links_with_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "yellow", opacity = 1, label = ~linkid)
}

for (link in unique(links_no_stats$linkid)) {
  map_df <- links_no_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red", opacity = 1, label = ~linkid)
}

map_links_with_stats
```


```{r}
# Calculate total travel time per logtime and direction
links_times <- link_stats %>% 
    group_by(logtime, direction) %>% 
    summarise(links_time = sum(tt)) %>% 
    ungroup() %>% 
    mutate(day = date(logtime),
           time = as_hms(logtime),
           hour = hour(logtime),
           rush = case_when(
             between(hour, 6, 9) ~ "morning",
             between(hour, 15, 18) ~ "evening",
             TRUE ~ "neither"),
           rush = factor(rush, levels = c("morning", "evening", "neither"))) %>% 
    relocate(day:rush, .after = logtime)
```

```{r}
ggplot(links_times, aes(links_time)) +
  geom_histogram()

ggplot(links_times, aes(links_time)) +
  geom_boxplot()
```

# Analysis

```{r}
# Split trips into 5 minute intervals
trip_times_5min <- trip_times %>% 
  mutate(arrival_time = ceiling_date(arrival_time, "5 minutes"),
         time = as_hms(arrival_time),
         hour = hour(time),
         rush = case_when(
             between(hour, 6, 9) ~ "morning",
             between(hour, 15, 18) ~ "evening",
             TRUE ~ "neither"),
         rush = factor(rush, levels = c("morning", "evening", "neither"))) %>% 
  relocate(rush:hour, .after = arrival_time)
```

## Compare bus travel times to links travel times to validate each other

```{r}
# Average trip time per interval
trip_times_agg <- trip_times_5min %>% 
  group_by(arrival_time, start_date, time, hour, rush, direction) %>% 
  summarise(number_buses = n(),
            bus_time = round(mean(trip_time))) %>% 
  ungroup()

# Combine
travel_times <- trip_times_agg %>%
  inner_join(links_times, by = c("arrival_time" = "logtime", "start_date" = "day", "time", "hour", "rush", "direction")) %>% 
  rename(datetime = arrival_time,
         day = start_date) %>% 
  mutate(travel_diff = bus_time - links_time)

travel_times_piv <- travel_times %>% 
  pivot_longer(cols = bus_time:links_time, names_to = "type", values_to = "travel_time")
```

```{r}
# Travel time distributions
travel_times_piv %>% 
  ggplot(aes(x = travel_time, fill = type)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank())

travel_times_piv %>% 
  ggplot(aes(x = travel_time, fill = type)) +
  geom_density(alpha = 0.5) +
  facet_wrap(vars(direction)) +
  theme_bw() +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank())

# Travel difference distributions
travel_times %>% 
  ggplot(aes(travel_diff)) +
  geom_histogram() +
  theme_bw()

travel_times %>% 
  ggplot(aes(travel_diff)) +
  geom_histogram() +
  facet_wrap(vars(direction)) +
  theme_bw()

# To City
travel_times_to_city <- travel_times %>% 
  filter(direction == "to_city")

travel_times_piv_to_city <- travel_times_piv %>% 
  filter(direction == "to_city")

travel_times_piv_to_city %>%
  ggplot(aes(x = time, y = travel_time, color = type)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("To City") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        legend.title = element_blank(),
        legend.justification = "bottom",
        legend.position = c(0.5, 0))

travel_times_to_city %>%
  ggplot(aes(time, travel_diff)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("To City") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank())

# From City
travel_times_from_city <- travel_times %>% 
  filter(direction == "from_city")

travel_times_piv_from_city <- travel_times_piv %>% 
  filter(direction == "from_city")

travel_times_piv_from_city %>%
  ggplot(aes(x = time, y = travel_time, color = type)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("From City") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        legend.title = element_blank(),
        legend.justification = "bottom",
        legend.position = c(0.5, 0))

travel_times_from_city %>%
  ggplot(aes(time, travel_diff)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("From City") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank())

# Scatter plots
travel_times %>% 
  ggplot(aes(bus_time, links_time)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  theme_bw()

travel_times %>% 
  ggplot(aes(bus_time, links_time)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  facet_wrap(vars(direction), scales = "free") +
  theme_bw()
```

```{r}
with(travel_times, cor(bus_time, links_time))

travel_times %>% 
  group_by(direction) %>% 
  summarise(correlation = cor(bus_time, links_time))
```

## Correlations

### No averaging

#### Standardized based on 5 minute time periods, hour, or peak time

```{r}
standardiser <- function(basis = time) {
  if (!deparse(substitute(basis)) %in% c("time", "hour", "rush")) {
    stop("basis must be either time, hour, or rush")
  }
  
  # Trip time standardized per 5 minute period per direction
  trip_times_std <<- trip_times_5min %>% 
    group_by({{basis}}, direction) %>% 
    mutate(period_buses_no = n(),
           bus_time_std = as.vector(scale(trip_time))) %>% 
    ungroup() %>%
    mutate(bus_time_std = if_else(is.nan(bus_time_std), 0, bus_time_std)) %>% 
    filter(abs(bus_time_std) < 3) %>% 
    select(start_date, time, hour, rush, direction, period_buses_no, bus_time_std)
    
  # Calculate travel time across all links standardized per 5 minute period per direction
  links_times_std <<- links_times %>% 
    group_by({{basis}}, direction) %>% 
    mutate(links_time_std = as.vector(scale(links_time))) %>% 
    ungroup() %>% 
    filter(abs(links_time_std) < 3) %>%
    select(-links_time, -logtime)
  
  # Combine
  travel_times_std <<- trip_times_std %>%
    inner_join(links_times_std, by = c("start_date" = "day", "time", "hour", "rush", "direction")) %>% 
    rename(day = start_date) %>% 
    mutate(std_travel_diff = bus_time_std - links_time_std)
  
  travel_times_std_piv <<- travel_times_std %>% 
    pivot_longer(cols = bus_time_std:links_time_std, names_to = "type", values_to = "std_travel_time")
}

standardiser(hour)
```

#### Visualise bus time and links time

```{r}
travel_times_std %>% 
  ggplot(aes(bus_time_std)) +
  geom_histogram()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(bus_time_std)) +
  geom_histogram() +
  facet_grid(vars(rush), vars(direction), scales = "free_y")

travel_times_std %>% 
  ggplot(aes(bus_time_std)) +
  geom_boxplot()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(bus_time_std)) +
  geom_boxplot() +
  facet_grid(vars(rush), vars(direction))

travel_times_std %>% 
  ggplot(aes(links_time_std)) +
  geom_histogram()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std)) +
  geom_histogram() +
  facet_grid(vars(rush), vars(direction), scales = "free_y")

travel_times_std %>% 
  ggplot(aes(links_time_std)) +
  geom_boxplot()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std)) +
  geom_boxplot() +
  facet_grid(vars(rush), vars(direction))
```

#### Scatter plots

```{r}
travel_times_std %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf,fill = "red", alpha = .1) +
  ggtitle("All Times") +
  theme_bw()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf, fill = "red", alpha = .1) +
  geom_smooth(se = FALSE) +
  ggtitle("Peak Times") +
  theme_bw()

travel_times_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  facet_grid(vars(rush), vars(direction)) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf, fill = "red", alpha = .1) +
  theme_bw()
```

#### Correlation coefficients

```{r}
# All times correlation
with(travel_times_std, cor(bus_time_std, links_time_std))

# Peak times correlation
with(filter(travel_times_std, rush != "neither"), cor(bus_time_std, links_time_std))

# Peak times and direction correlation
travel_times_std %>% 
  filter(rush != "neither") %>% 
  group_by(rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std)) %>% 
  ungroup()

# Time period correlation
travel_times_std_cor <- travel_times_std %>%
  filter(rush != "neither") %>%
  group_by(time, rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std),
            sample_size = n()) %>% 
  ungroup() %>% 
  na.omit()

travel_times_std_cor %>% 
  ggplot(aes(time, correlation)) +
  geom_line() +
  facet_grid(vars(direction), vars(rush), scales = "free_x") +
  theme_bw()

# Hourly correlation
travel_times_std_hr_cor <- travel_times_std %>%
  filter(rush != "neither") %>%
  group_by(hour, rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std),
            sample_size = n()) %>% 
  ungroup() %>% 
  na.omit()

travel_times_std_hr_cor %>% 
  ggplot(aes(hour, correlation)) +
  geom_line() +
  facet_grid(vars(direction), vars(rush), scales = "free_x") +
  theme_bw()
```

### Averaging bus times per 5 minute period if more than one trip

```{r}
standardiser_avg <- function(basis = time) {
  if (!deparse(substitute(basis)) %in% c("time", "hour", "rush")) {
    stop("basis must be either time, hour, or rush")
  }
  
  # Average trip_times in the same 5 minute datetime
  trip_times_avg <- trip_times_5min %>% 
    group_by(start_date, time, hour, rush, direction) %>% 
    summarise(trip_time = mean(trip_time)) %>% 
    ungroup()
  
  # Trip time standardized per 5 minute period per direction
  trip_times_avg_std <- trip_times_avg %>% 
    group_by({{basis}}, direction) %>% 
    mutate(period_buses_no = n(),
           bus_time_std = as.vector(scale(trip_time))) %>% 
    ungroup() %>% 
    mutate(bus_time_std = if_else(is.nan(bus_time_std), 0, bus_time_std)) %>%
    filter(abs(bus_time_std) < 3) %>%
    select(-trip_time)
    
  # Calculate travel time across all links standardized per 5 minute period per direction
  links_times_std <- links_times %>% 
    group_by({{basis}}, direction) %>% 
    mutate(links_time_std = as.vector(scale(links_time))) %>% 
    ungroup() %>% 
    filter(abs(links_time_std) < 3) %>%
    select(-links_time, -logtime)
  
  # Combine
  travel_times_avg_std <<- trip_times_avg_std %>%
    inner_join(links_times_std, by = c("start_date" = "day", "time", "hour", "rush", "direction")) %>% 
    rename(day = start_date) %>% 
    mutate(std_travel_diff = bus_time_std - links_time_std)
  
  travel_times_avg_std_piv <<- travel_times_avg_std %>% 
    pivot_longer(cols = bus_time_std:links_time_std, names_to = "type", values_to = "std_travel_time")
}

standardiser_avg(rush)
```

#### Visualise bus time and links time

```{r}
travel_times_avg_std %>% 
  ggplot(aes(bus_time_std)) +
  geom_histogram()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(bus_time_std)) +
  geom_histogram() +
  facet_grid(vars(rush), vars(direction), scales = "free_y")

travel_times_avg_std %>% 
  ggplot(aes(bus_time_std)) +
  geom_boxplot()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(bus_time_std)) +
  geom_boxplot() +
  facet_grid(vars(rush), vars(direction))

travel_times_avg_std %>% 
  ggplot(aes(links_time_std)) +
  geom_histogram()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std)) +
  geom_histogram() +
  facet_grid(vars(rush), vars(direction), scales = "free_y")

travel_times_avg_std %>% 
  ggplot(aes(links_time_std)) +
  geom_boxplot()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std)) +
  geom_boxplot() +
  facet_grid(vars(rush), vars(direction))
```

```{r}
# To City
travel_times_avg_std_to_morn <- travel_times_avg_std %>% 
  filter(direction == "to_city",
         rush == "morning")

travel_times_avg_std_piv_to_morn <- travel_times_avg_std_piv %>% 
  filter(direction == "to_city",
         rush == "morning")

travel_times_avg_std_piv_to_morn %>%
  ggplot(aes(x = time, y = std_travel_time, color = type)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("To City") +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.justification = "bottom",
        legend.position = c(0.5, 0))

travel_times_avg_std_to_morn %>%
  ggplot(aes(time, std_travel_diff)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("To City") +
  theme_bw()

# From City
travel_times_avg_std_from_eve <- travel_times_avg_std %>% 
  filter(direction == "from_city",
         rush == "evening")

travel_times_avg_std_piv_from_eve <- travel_times_avg_std_piv %>% 
  filter(direction == "from_city",
         rush == "evening")

travel_times_avg_std_piv_from_eve %>%
  ggplot(aes(x = time, y = std_travel_time, color = type)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("From City") +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.justification = "bottom",
        legend.position = c(0.5, 0))

travel_times_avg_std_from_eve %>%
  ggplot(aes(time, std_travel_diff)) +
  geom_line() +
  facet_wrap(vars(day)) +
  ggtitle("From City") +
  theme_bw()
```

#### Scatter plots

```{r}
travel_times_avg_std %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf,fill = "red", alpha = .1) +
  ggtitle("All Times") +
  theme_bw()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf, fill = "red", alpha = .1) +
  geom_smooth(se = FALSE) +
  ggtitle("Peak Times") +
  theme_bw()

travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  ggplot(aes(links_time_std, bus_time_std)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  facet_grid(vars(rush), vars(direction)) +
  annotate("rect", xmin = 0, xmax = Inf, ymin = 0, ymax = Inf, fill = "red", alpha = .1) +
  theme_bw()
```

#### Correlation coefficients

```{r}
# All times correlation
with(travel_times_avg_std, cor(bus_time_std, links_time_std))

# Peak times correlation
with(filter(travel_times_avg_std, rush != "neither"), cor(bus_time_std, links_time_std))

# Peak times and direction correlation
travel_times_avg_std %>% 
  filter(rush != "neither") %>% 
  group_by(rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std)) %>% 
  ungroup()

# Time period correlation
travel_times_avg_std_cor <- travel_times_avg_std %>%
  filter(rush != "neither") %>%
  group_by(time, rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std),
            sample_size = n()) %>% 
  ungroup() %>% 
  na.omit()

travel_times_avg_std_cor %>% 
  ggplot(aes(time, correlation)) +
  geom_line() +
  facet_grid(vars(direction), vars(rush), scales = "free_x") +
  theme_bw()

# Hourly correlation
travel_times_avg_std_hr_cor <- travel_times_avg_std %>%
  filter(rush != "neither") %>%
  group_by(hour, rush, direction) %>% 
  summarise(correlation = cor(bus_time_std, links_time_std),
            sample_size = n()) %>% 
  ungroup() %>% 
  na.omit()

travel_times_avg_std_hr_cor %>% 
  ggplot(aes(hour, correlation)) +
  geom_line() +
  facet_grid(vars(direction), vars(rush), scales = "free_x") +
  theme_bw()
```






