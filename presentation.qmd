---
title: "Bus Travel Times Variations vs Motor Vehicle Travel Times Variations"
author: "Ibrahim Al-Hindi"
format: revealjs
editor: visual
knitr:
  opts_chunk: 
    echo: FALSE
    message: FALSE
    warning: FALSE
    cache: TRUE
    fig.align: "center"
---

```{r}
#| include: false
library(tidyverse)
library(here)
library(lubridate)
library(leaflet)
library(hms)
library(janitor)
library(broom)
library(kableExtra)
library(scales)

# Holidays dates
holidays_raw <- read_csv(here("data/DIT/specialdays.csv"))

# Links information
links_raw <- read_csv(here("data/DIT/links.csv"))

# List of links on South Rd and their geometries
southrd_links_raw <- read_csv(here("data/South-Rd/Links - South Rd.csv"))

# List of links on Marion Rd and their geometries
marionrd_links_raw <- read_csv(here("data/Marion-Rd/Marion Rd Links.csv"))

# Stops information
full_stops_raw <- read_csv(here("data/GTFS/stops.csv"))

# Routes, trips, and stops on South Rd
southrd_routes_stops_raw <- read_csv(here("data/South-Rd/South Rd Routes and Trips gtfs 1157.csv"))

# Routes, trips, and stops on Marion Rd
marionrd_routes_stops_raw <- read_csv(here("data/Marion-Rd/Marion Rd Routes Stops.csv"))

# GTFS-R Trip Updates for South Rd
southrd_updates_raw <- read_csv(here("data/South-Rd/trip_updates_SouthRd_Mar.csv"))

# GTFS-R Trip Updates for Marion Rd
marionrd_updates_raw <- read_csv(here("data/Marion-Rd/trip_updates_MarionRd_Mar.csv"))

# South Rd link statistics
southrd_link_stats_raw <- read_csv(here("data/South-Rd/link_stats_Mar.csv"))

# Marion Rd link statistics
marionrd_link_stats_raw <- read_csv(here("data/Marion-Rd/link_stats_Mar.csv"))
```

## Background

-   Adelaide's increasing population along with travel KM's

-   Costly road congestion projected to increase in the coming years

-   Client is South Australia Department of Infrastructure and Transport (DIT)

## Objectives

::: r-fit-text
#### Process to formulate

-   Initial data exploration (lots of data)

-   Client proposal created followed by discussion with the client

#### Objectives

1.  Investigate the extent of the relationship between the **variation** in bus travel times vs the **variation** in motor vehicle travel time in a given segment of road. Provides an indicated or road robustness to congestion

2.  Methodology and code as repeatable and automated as possible

Analysis done on South Road during March 2022
:::

## South Road

![](images/SouthRd_Map.png){fig-align="center" width="100%"}

## South Road

![](images/southrd.jfif){fig-align="center" width="100%"}

## Data

::: r-fit-text
1.  **General Transit Feed Specification (GTFS)**

    Static or scheduled information about public transport services such as routes, stops, schedule and geographic transit information

<br>

2.  **General Transit Feed Specification Realtime (GTFSR)**

    Real time information consisting of

    i.  expected arrival times and delays

    ii. geographic position and speed

<br>

3.  **DIT**

    Traffic information collected by DIT using Bluetooth devices on the roads. The location of a Bluetooth device is called a site, and a link is a segment of road between two sites, an origin site and a destination site

<br>

All data is stored in DIT's AWS
:::

## GTFS {.scrollable}

::: panel-tabset
## Routes

Segment route ID's extracted through Tableau

## Stops

Also extracted through Tableau

```{r}
segment_route_stops <- clean_names(southrd_routes_stops_raw)
  
segment_routes <- segment_route_stops %>% 
  pull(route_id) %>% 
  unique()

segment_stops <- segment_route_stops %>% 
  pull(stop_id_gtfs_history_prod_stops_csv) %>% 
  unique()

# Join stops information to stops on the segment
stops_segment <- full_stops_raw %>%
  filter(stop_id %in% segment_stops) %>%
  select(stop_id, stop_name, stop_desc, stop_lat, stop_lon) %>%
  distinct(stop_id, .keep_all = TRUE) %>%
  # If stop is on East side, that means trip SB, and vice versa
  mutate(direction = if_else(str_detect(stop_name, "East"), "SB", "NB"))

rm(southrd_routes_stops_raw)

stops_segment %>% 
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Unique stop identifier",
                         "Name of the location. Uses a name that people will understand",
                         "Address of the stop",
                         "Latitude of the stop",
                         "Longitude of the stop",
                         "Road direction of the stop")) %>% 
  kable() %>% 
  kable_styling()
```
:::

## Stops Map

```{r}
# Plot on map to check the stops are all on South Rd
stops_segment %>%
    leaflet() %>% 
    addTiles() %>% 
    addCircles(lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, opacity = 1)
```

## GTFSR - Trip Updates {.scrollable}

```{r}
updates <- southrd_updates_raw %>%
  rename(
    trip_id = id,
    vehicle_id = label) %>%
  mutate(
    start_date = ymd(start_date),
    timestamp = as_datetime(timestamp, tz = "Australia/Adelaide"),
    arrival_time = as_datetime(arrival_time, tz = "Australia/Adelaide")) %>%
  select(-direction_id, -wheelchair_accessible)
```

::: panel-tabset
## Data

```{r}
updates %>% 
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Unique route identifier",
                         "Start date of the trip",
                         "Unique vehicle identifier",
                         "Timestamp of the real time update",
                         "Unique trip identifier",
                         "Order of stops for a particular trip",
                         "Unique stop identifier",
                         "The current schedule deviation for the trip. 
                         The delay (in seconds) can be positive (meaning that the vehicle is late) 
                         or negative (meaning that the vehicle is ahead of schedule)", 
                         "Predicted arrival time for a stop on a particular trip")) %>% 
  kable() %>% 
  kable_styling()
```

## Notes

-   One `route_id` can have many `trip_id`s

-   One `trip_id` occurs a maximum of one time a day, the `trip_id` can occur on multiple days

-   Latest update per stop

-   Trip stops within segment only

-   Removed weekends and holidays

-   Many errors

-   Trip time is calculated as time between first stop and last stop arrival times
:::

## Trip Updates Cleaning

::: panel-tabset
## Pre-Cleaning

```{r}
holidays <- unique(holidays_raw$date)
rm(holidays_raw)
updates <- updates %>%
  inner_join(select(stops_segment, stop_id, direction), by = "stop_id") %>%
  filter(
    !start_date %in% holidays,
    !wday(start_date, label = TRUE) %in% c("Sat", "Sun"))
updates_stop_times <- updates %>%
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  mutate(to_stop_time = as.numeric(arrival_time - lag(arrival_time), units = "secs")) %>%
  ungroup() %>%
  mutate(to_stop_time = replace_na(to_stop_time, 0))

ggplot(updates_stop_times, aes(to_stop_time/60, delay/60)) +
  geom_point(alpha = 0.3) +
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  scale_x_continuous(labels = label_comma()) +
  scale_y_continuous(labels = label_comma()) +
  labs(x = "To-Stop Time (Minutes)",
       y = "Delay (Minutes)",
       title = "Unedited Trip To-Stop Time Vs. Delay") +
  theme_bw()
```

## Cleaning Code

```{r}
#| echo: true
# Clean updates and get time to each stop for error detection
updates_stop_times <- updates %>%
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  # Remove trips where all the stops have a delay over 2400 (40 minutes) or
  # early by more than 900 (15 minutes), ie entire trip is delayed or early.
  # Most likely error due to entering the information later. This is done to prevent
  # incorrect analysis since they will be in the wrong time period
  filter(!(all(delay > 2400) |
           all(delay < -900))) %>%
  # Remove one-off large jumps in between two observations
  filter(!(delay - lag(delay, order_by = stop_sequence, default = 0) > 1000 &
             delay - lead(delay, order_by = stop_sequence, default = 0) > 1000)) %>%
  # Remove any observations that have an arrival_time later than any following
  # arrival_time in the trip AND the timestamp is earlier than any following timestamps in the trip.
  # This ensures the most recent timestamp is preferred when discrepancy occurs
  filter(!(as.numeric(arrival_time) > order_by(-stop_sequence, cummin(as.numeric(arrival_time))) &
             as.numeric(timestamp) == order_by(-stop_sequence, cummin(as.numeric(timestamp))))) %>%
  # Remove if the arrival_time is less than the previous arrival_times AND the timestamp
  # is older than the previous timestamps
  filter(!(arrival_time < order_by(stop_sequence, cummax(as.numeric(arrival_time))) &
             timestamp < order_by(stop_sequence, cummax(as.numeric(timestamp))))) %>%
  # If arrival_time of a stop is less than prior stops but they all have the same
  # timestamp, it's not possible to know which is correct. Assume earlier stop_sequence
  # is correct since it is closer when the update is made
  filter(!(timestamp == order_by(stop_sequence, cummax(as.numeric(timestamp))) &
             arrival_time < order_by(stop_sequence, cummax(as.numeric(arrival_time))))) %>%
  # If after the above, two consecutive stops have the same arrival_time, remove
  # the one with an older timestamp
  filter(!(arrival_time == lead(arrival_time,
                                order_by = stop_sequence,
                                default = ymd("9999-01-01")) &
             timestamp < lead(timestamp,
                              order_by = stop_sequence,
                              default = ymd("9999-01-01")))) %>%
  # If two stops have the same arrival_time and same time_stamp, remove the one
  # with a higher stop sequence. Make sure only 2 stops and not more
  filter(!(arrival_time != lead(arrival_time,
                                order_by = stop_sequence,
                                default = ymd("9999-01-01")) &
             arrival_time == lag(arrival_time,
                                 order_by = stop_sequence,
                                 default = ymd("0000-01-01")) &
             timestamp == lag(timestamp,
                              order_by = stop_sequence,
                              default = ymd("0000-01-01")))) %>%
  # Remove trips with multiple repeating arrival_times
  filter(!n_distinct(arrival_time) < n()) %>%
  mutate(
    to_stop_time = as.numeric(arrival_time - lag(arrival_time), units = "secs"),
    first_stop = first(stop_id, order_by = stop_sequence),
    last_stop = last(stop_id, order_by = stop_sequence)) %>%
  ungroup() %>%
  mutate(to_stop_time = replace_na(to_stop_time, 0))
```

## Post-Cleaning

```{r}
ggplot(updates_stop_times, aes(to_stop_time/60, delay/60)) +
  geom_point(alpha = 0.3) +
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  scale_x_continuous(labels = label_comma()) +
  scale_y_continuous(labels = label_comma()) +
  labs(x = "To-Stop Time (Minutes)",
       y = "Delay (Minutes)",
       title = "Cleaned Trip To-Stop Time Vs. Delay") +
  theme_bw()
```
:::

## Multiple Stops Pairs

Different pairs of start-end stops per direction lead to non-consistent travel times

```{r}
# Take top occurring stops pair for each direction
top_first_last_stops <- updates_stop_times %>%
  distinct(start_date, trip_id, direction, first_stop, last_stop) %>%
  group_by(direction) %>%
  count(first_stop, last_stop, sort = TRUE) %>%
  slice_max(order_by = n, n =2) %>%
  ungroup()

# Get trips with only most occurring stops pair per direction identified
updates_stop_times_x <- updates_stop_times %>%
  semi_join(top_first_last_stops, by = c("direction", "first_stop", "last_stop"))

updates_trip_time <- updates_stop_times_x %>%
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  mutate(trip_time = as.numeric((last(arrival_time) -first(arrival_time)), units = "secs"),
         delay_diff = abs(last(delay) - first(delay))) %>%
  filter(stop_sequence == first(stop_sequence, order_by = stop_sequence)) %>%
  ungroup() %>%
  distinct(start_date, trip_id, .keep_all = TRUE) %>% 
  mutate(stops_pair = paste0(first_stop, "-", last_stop))

ggplot(updates_trip_time, aes(trip_time/60, fill = stops_pair)) +
  geom_density(alpha = 0.5) +
  scale_x_continuous(labels = label_comma()) +
  labs(x = "Trip Time (Minutes)",
       fill = "First-Last Stops",
       title = "Trip Time Distribution per Stops Pair per Direction") +
  facet_wrap(vars(direction)) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank())
```

## Most Occurring Stops Pair

```{r}
top_first_last_stops <- updates_stop_times %>%
  distinct(start_date, trip_id, direction, first_stop, last_stop) %>%
  group_by(direction) %>%
  count(first_stop, last_stop, sort = TRUE) %>%
  slice_max(order_by = n) %>%
  ungroup()

stops_segment %>%
  filter(stop_id %in% c(top_first_last_stops$first_stop, top_first_last_stops$last_stop)) %>% 
  leaflet() %>% 
  addTiles() %>% 
  addCircles(lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, opacity = 1)
```

## Bus Travel Times Distributions

::: panel-tabset
## All Times

```{r}
updates_stop_times <- updates_stop_times %>%
  semi_join(top_first_last_stops, by = c("direction", "first_stop", "last_stop"))

updates_trip_time <- updates_stop_times %>%
  group_by(start_date, trip_id) %>%
  arrange(stop_sequence, .by_group = TRUE) %>%
  mutate(
    trip_time = as.numeric((last(arrival_time) -first(arrival_time)), units = "secs"),
    delay_diff = abs(last(delay) - first(delay))) %>%
  ungroup()

updates_trip_time <- updates_trip_time %>%
  # If the delay_diff is greater than 600 (10 minutes), most likely an error
  filter(delay_diff < 600) %>%
  arrange(start_date, trip_id, stop_sequence)

trip_times <- updates_trip_time %>%
  group_by(start_date, trip_id) %>%
  filter(stop_sequence == first(stop_sequence, order_by = stop_sequence)) %>%
  ungroup() %>%
  distinct(start_date, trip_id, .keep_all = TRUE) %>% 
  mutate(
    rush = case_when(
      as_hms("06:00:00") <= as_hms(arrival_time) & as_hms(arrival_time) < as_hms("10:00:00") ~ "Morning",
      as_hms("15:00:00") <= as_hms(arrival_time) & as_hms(arrival_time) < as_hms("19:00:00") ~ "Evening",
      TRUE ~ "Neither"),
    rush = factor(rush, levels = c("Morning", "Evening", "Neither"))) %>% 
  select(-delay_diff)

rm(southrd_updates_raw)

ggplot(trip_times, aes(trip_time/60, fill = direction)) +
  geom_density(alpha = 0.4) +
  labs(x = "Trip Time (Minutes)",
       fill = "Direction",
       title = "Trip Time Distribution per Direction at All Times") +
  scale_x_continuous(labels = label_comma()) +
  scale_y_continuous(labels = label_comma()) +
  theme_bw()
```

## Peak Times

```{r}
trip_times %>% 
  filter(rush != "Neither") %>% 
  ggplot(aes(trip_time/60, fill = direction)) +
  geom_density(alpha = 0.3) +
  labs(x = "Trip Time (Minutes)",
       fill = "Direction",
       title = "Trip Time Distribution per Direction by Rush Hours") +
  scale_x_continuous(labels = label_comma()) +
  scale_y_continuous(labels = label_comma()) +
  facet_wrap(vars(rush)) +
  theme_bw()
```
:::

## Trip Times Segregation {.scrollable}

1.  Split data into five minute time periods using first stop arrival time

2.  Average bus travel time per five minute period

```{r}
trip_times_agg <- trip_times %>% 
  mutate(arrival_time = ceiling_date(arrival_time, "5 minutes")) %>% 
  group_by(arrival_time, direction) %>% 
  summarise(
    number_buses = n(),
    bus_time = round(mean(trip_time))) %>%
  ungroup() %>% 
  mutate(
    day = date(arrival_time),
    time = as_hms(arrival_time),
    hour = hour(time),
    rush = case_when(
      between(hour, 6, 9) ~ "Morning",
      between(hour, 15, 18) ~ "Evening",
      TRUE ~ "Neither"),
    rush = factor(rush, levels = c("Morning", "Evening", "Neither"))) %>% 
  relocate(day:rush, .after = arrival_time) %>% 
  select(-arrival_time)

trip_times_agg %>%
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Date of measurement",
                         "Time of the day in hour:minute:seconds of the measurement",
                         "The hour of the measurement",
                         "Whether the measurement occurrs during rush hour.
                          Morning rush hour occurrs between 6am and 10am,
                          evening rush hour occurrs between 3pm and 7pm,
                          neither otherwise",
                         "The direction of travel",
                         "The original number of trips during the five minute interval",
                         "The bus trip travel time across the segment")) %>% 
  kable() %>% 
  kable_styling()
```

## DIT - Links {.scrollable}

Segment links extracted using Tableau

```{r}
# Limit updates to end of period examined and get most recent update per link,
# this is done to get the most recent enabled status for each link
links <- links_raw %>%
  filter(date(dms_update_ts) < "2022-04-01") %>%
  group_by(id) %>%
  filter(dms_update_ts == max(dms_update_ts)) %>%
  ungroup() %>%
  select(id, originid:length, direction) %>%
  distinct()

links_segment <- southrd_links_raw %>%
  rename_with(tolower) %>%
  mutate(
    latitude = round(latitude, 5),
    longitude = round(longitude, 5),
    # Extract name of locations where link starts and ends
    start_loc = str_extract(name, "(?<=- ).*(?= to)"),
    end_loc = str_extract(name, "(?<=to ).*")) %>%
  # Extract the latitudes of where the link starts and ends
  group_by(linkid) %>%
  mutate(
    start_lat = first(latitude, order_by = ordernumber),
    end_lat = last(latitude, order_by = ordernumber)) %>%
  ungroup() %>%
  # Length in southrd_links_raw is not correct, join with links to get correct lengths and direction
  select(-length) %>%
  left_join(links, by = c("linkid" = "id"))

# Get only first entry per link
links_segment_unq <- links_segment %>%
  arrange(linkid, ordernumber) %>%
  distinct(linkid, .keep_all = TRUE)

directions <- sort(unique(links_segment_unq$direction))

rm(links_raw)
rm(southrd_links_raw)

links_segment %>%
  relocate(name, .after = linkid) %>% 
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Unique link identifier",
                         "Description of link",
                         "Order of geometry coordinates",
                         "Latitude",
                         "Longitude",
                         "Name of link start location",
                         "Name of link end location",
                         "Latitude of the link's first shape coordinate",
                         "Latitude of the link's last shape coordinate",
                         "The Bluetooth site ID that begins the link",
                         "The Bluetooth site ID that ends the link", 
                         "Boolean. Disabled links do not generate statistics",
                         "The link length in metres",
                         "Link direction of travel")) %>% 
  kable() %>% 
  kable_styling()
```

## Links Statistics

-   5 minute aggregated statistics per link, including travel time

-   However, links extracted contain links that overlap. Need to identify non-overlapping sequence of links to avoid double counting

-   Total length of the sequence of links needs to be approximately the same as the length between the stops pairs

-   Impute statistics for links with missing statistics

-   Multiple iterations trialed

-   Minimum manual input

## Links Identification

::: panel-tabset
## Steps

Use northbound direction for illustration

1.  Order links from south to north

2.  Only enabled links

3.  Using stops map, enter names of start and stop locations. Filter links to exist within these locations

4.  If two links have the same distance, choose the shorter one

## Code

```{r}
#| echo: true
links_dir1 <- links_segment_unq %>%
  # Build map from south to north
  filter(direction == directions[1]) %>% 
  arrange(start_lat)

links_dir1_enabled <- links_dir1 %>%
  filter(enabled)

# Start and end at same locations as bus stops by referencing map above
dir1_start_loc <- "celtic"
dir1_end_loc <- "anzac"

# Retrieve sequence of links composing segment
links_dir1_enabled <- links_dir1_enabled[min(which(str_starts(tolower(links_dir1_enabled$start_loc),
                                                                  tolower(dir1_start_loc)))):
                                               max(which(str_starts(tolower(links_dir1_enabled$end_loc),
                                                                    tolower(dir1_end_loc)))),] %>% 
  group_by(start_loc) %>%
  filter(length == min(length)) %>%
  ungroup()

# Obtain shape for each link
links_dir1_map <- links_segment %>% 
  semi_join(links_dir1_enabled, by = "linkid") %>% 
  arrange(start_lat, ordernumber)

# Create map

links_colors <- c("green","red")

n <- 1

map_dir1 <- leaflet() %>% 
  addTiles()

# Iterate over links to add polyline of each link to the map
for (link in unique(links_dir1_map$linkid)) {
  map_df <- links_dir1_map %>% 
    filter(linkid == link)
  
  map_dir1 <- map_dir1 %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = links_colors[n],
                 label = ~linkid, opacity = 0.3)
  
  # Switch colors
  if (n == 1) {
    n <- 2
  } else {
    n <- 1
  }
}

dir1_stops <- stops_segment %>%
  filter(stop_id %in% c(top_first_last_stops[top_first_last_stops["direction"] == directions[1],]$first_stop,
                        top_first_last_stops[top_first_last_stops["direction"] == directions[1],]$last_stop))


```
:::

```{r}

links_dir2 <- links_segment_unq %>%
  filter(direction == directions[2]) %>% 
  arrange(-start_lat)

links_dir2_enabled <- links_dir2 %>%
  filter(enabled)

dir2_start_loc <- "anzac"
dir2_end_loc <- "celtic"

links_dir2_enabled <- links_dir2_enabled[min(which(str_starts(tolower(links_dir2_enabled$start_loc),
                                                                  tolower(dir2_start_loc)))):
                                               max(which(str_starts(tolower(links_dir2_enabled$end_loc),
                                                                    tolower(dir2_end_loc)))),] %>% 
  group_by(start_loc) %>%
  filter(length == min(length)) %>%
  ungroup()

links_dir2_map <- links_segment %>% 
  semi_join(links_dir2_enabled, by = "linkid") %>% 
  arrange(-start_lat, ordernumber)

links_colors <- c("green","red")

n <- 1

map_dir2 <- leaflet() %>% 
  addTiles()

for (link in unique(links_dir2_map$linkid)) {
  map_df <- links_dir2_map %>% 
    filter(linkid == link)
  
  map_dir2 <- map_dir2 %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = links_colors[n],
                 label = ~linkid, opacity = 0.3)

  if (n == 1) {
    n <- 2
  } else {
    n <- 1
  }
}

dir2_stops <- stops_segment %>%
  filter(stop_id %in% c(top_first_last_stops[top_first_last_stops["direction"] == directions[2],]$first_stop,
                        top_first_last_stops[top_first_last_stops["direction"] == directions[2],]$last_stop))
```

## Non-Overlapping Links Map

```{r}
map_both <- leaflet() %>% 
  addTiles()

# Add links first direction
for (link in unique(links_dir1_map$linkid)) {
  map_df <- links_dir1_map %>% 
    filter(linkid == link)
  
  map_both <- map_both %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "green", 
                 opacity = 0.3, label = ~linkid)
}

# Add links second direction
for (link in unique(links_dir2_map$linkid)) {
  map_df <- links_dir2_map %>% 
    filter(linkid == link)
  
  map_both <- map_both %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red",
                 opacity = 0.3, label = ~linkid)
}

map_both %>% 
  addCircles(data = dir1_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1) %>%
  addCircles(data = dir2_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1)
```

## Impute Statistics for Links with No Statistics {.scrollable}

::: panel-tabset
## Steps

1.  Identify linkid of link with no statistics

2.  Identify closest enabled links before and after missing link

3.  Retrieve and clean link statistics

4.  For preceding and proceeding links, calculate travel time divided by the length of the link per five minute period

5.  Average (4) between the preceding and proceeding links per five minute period

6.  Multiply (5) by the length of the missing link to obtain the travel time for each five minute period

## Steps 1-2 Code

```{r}
#| echo: true
# DF for missing links imputation
missing_links_impute <- tibble(from = character(),
                               to = character(),
                               linkid = numeric(),
                               prior_linkid = numeric(),
                               post_linkid = numeric(),
                               direction = character())

# For the missing link, retrieve the link as well closest enabled previous and 
# proceeding links for imputation later
missing_links_dir1 <- tibble(from = character(),
                        to = character())

# Add start and end locations of missing links
missing_links_dir1 <- missing_links_dir1 %>% 
  add_row(from = "walsh",
          to = "celtic")

for (i in 1:nrow(missing_links_dir1)) {
  
  from <- tolower(missing_links_dir1$from[i])
  to <- tolower(missing_links_dir1$to[i])
  
  for (a in 1:nrow(links_dir1)) {
    # Get linkid for missing link
    if (str_starts(tolower(links_dir1$start_loc[a]), from) && str_starts(tolower(links_dir1$end_loc[a]), to)) {
      
      linkid <- links_dir1$linkid[a]

      # Retrieve last prior link that is enabled
      prior_linkid <- links_dir1[1:a-1,] %>%
        filter(enabled) %>%
        slice_tail() %>%
        pull(linkid)

      # Retrieve first proceeding link that is enabled
      post_linkid <- links_dir1[a+1:nrow(links_dir1),] %>%
        filter(enabled) %>%
        slice_head() %>%
        pull(linkid)

      missing_links_impute <- missing_links_impute %>%
        add_row(from = from,
                to = to,
                linkid = linkid,
                prior_linkid = prior_linkid,
                post_linkid = post_linkid,
                direction = directions[1])
      break
    }
  }
}
```
:::

```{r}
missing_links_dir2 <- tibble(from = character(),
                        to = character())

missing_links_dir2 <- missing_links_dir2 %>% 
  add_row(from = "celtic",
          to = "walsh")

for (i in 1:nrow(missing_links_dir2)) {
  
  from <- tolower(missing_links_dir2$from[i])
  to <- tolower(missing_links_dir2$to[i])
  
  for (a in 1:nrow(links_dir2)) {
    if (str_starts(tolower(links_dir2$start_loc[a]), from) && str_starts(tolower(links_dir2$end_loc[a]), to)) {
      
      linkid <- links_dir2$linkid[a]
      
      prior_linkid <- links_dir2[1:a-1,] %>%
        filter(enabled) %>%
        slice_tail() %>%
        pull(linkid)

      post_linkid <- links_dir2[a+1:nrow(links_dir1),] %>%
        filter(enabled) %>%
        slice_head() %>%
        pull(linkid)

      missing_links_impute <- missing_links_impute %>%
        add_row(from = from,
                to = to,
                linkid = linkid,
                prior_linkid = prior_linkid,
                post_linkid = post_linkid,
                direction = directions[2])
      break
    }
  }
}

links_all <- unique(c(links_dir1_enabled$linkid, links_dir2_enabled$linkid,
                missing_links_impute$linkid,missing_links_impute$prior_linkid, 
                missing_links_impute$post_linkid))
```

## Link Statistics

```{r}
link_stats <- southrd_link_stats_raw %>% 
  select(logtime:avgdensity) %>%
  mutate(logtime = ymd_hms(str_remove(logtime, " \\+10:30"), tz = "Australia/Adelaide")) %>%
  filter(
    !as_date(logtime) %in% holidays,
    !wday(logtime, label = TRUE) %in% c("Sat", "Sun")) %>% 
  distinct()

# Join link_stats with links_segment to get direction and length
link_stats <- link_stats %>%
  left_join(select(links_segment_unq, linkid, direction, length)) %>%
  # Calculate speed km/h
  mutate(speed = round((length / 1000) / (tt / 3600)))

rm(southrd_link_stats_raw)

link_stats %>%
  select(-avgdensity, -density) %>% 
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Current interval timestamp",
                         "Unique link identifier",
                         "Travel time in seconds",
                         "The link direction of travel",
                         "The link length in metres",
                         "Calculated speed in km/h"
                         )) %>% 
  kable() %>% 
  kable_styling()
```

## Links Statistics Cleaning

::: panel-tabset
## Pre-Cleaning

```{r}
ggplot(link_stats, aes(speed, tt/60, color = factor(linkid))) +
  geom_point(alpha = 0.3, show.legend = FALSE) +
  labs(x = "Speed (km/h)", 
       y = "Vehicle Travel Time (minutes)", 
       title = "Unedited Vehicle Travel Speed Vs Travel Time") +
  theme_bw()
```

## Post-Cleaning

```{r}
link_stats <- link_stats %>%
  # Remove speeds over 150 km/h as most likely errors
  filter(speed < 150)

ggplot(link_stats, aes(speed, tt/60, color = factor(linkid))) +
  geom_point(alpha = 0.3, show.legend = FALSE) +
  labs(x = "Speed (km/h)", 
       y = "Vechile Travel Time (Minutes)", 
       title = "Vehicle Travel Speed Vs Travel Time") +
  theme_bw()
```
:::

## Maps of Links Before Imputation

```{r}
links_with_stats <- links_segment %>% 
  filter(linkid %in% c(links_dir1_enabled$linkid, links_dir2_enabled$linkid,
                       missing_links_impute$linkid)) %>% 
  semi_join(link_stats, by = "linkid")

links_no_stats <- links_segment %>% 
  filter(linkid %in% missing_links_impute$linkid) %>%  
  anti_join(link_stats, by = "linkid")
  
map_links_with_stats <- leaflet() %>% 
  addTiles()

# Draw links with stats in green
for (link in unique(links_with_stats$linkid)) {
  map_df <- links_with_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "green",
                 opacity = 1, label = ~linkid)
}

# Draw links with no stats in red
for (link in unique(links_no_stats$linkid)) {
  map_df <- links_no_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red",
                 opacity = 1, label = ~linkid)
}

map_links_with_stats %>% 
  addCircles(data = dir1_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1) %>%
  addCircles(data = dir2_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1)
```

## Maps of Links After Imputation

```{r}
for(i in 1:nrow(missing_links_impute)) {
  link_length <- links %>% 
    filter(id == missing_links_impute$linkid[i]) %>% 
    pull(length)
  
  link_estimates <- link_stats %>% 
  filter(linkid %in% c(missing_links_impute$prior_linkid[i], missing_links_impute$post_linkid[i])) %>% 
  mutate(time_len = tt / length) %>% 
  group_by(logtime) %>% 
  summarise(
    avg_time_len = mean(time_len),
    direction = unique(direction)) %>% 
  ungroup() %>% 
  mutate(
    linkid = missing_links_impute$linkid[i],
    tt = round(avg_time_len * link_length),
    length = link_length) %>% 
  select(-avg_time_len)
  
  link_stats <- link_stats %>% 
  full_join(link_estimates, by = names(link_estimates))
}

# Remove estimator links not in segment
link_stats <- link_stats %>% 
  filter(linkid %in% c(links_dir1_enabled$linkid, links_dir2_enabled$linkid,
                       missing_links_impute$linkid))

links_with_stats <- links_segment %>% 
  filter(linkid %in% c(links_dir1_enabled$linkid, links_dir2_enabled$linkid,
                       missing_links_impute$linkid)) %>% 
  semi_join(link_stats, by = "linkid")

links_no_stats <- links_segment %>% 
  filter(linkid %in% missing_links_impute$linkid) %>%  
  anti_join(link_stats, by = "linkid")
  
map_links_with_stats <- leaflet() %>% 
  addTiles()

for (link in unique(links_with_stats$linkid)) {
  map_df <- links_with_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "green",
                 opacity = 1, label = ~linkid)
}

for (link in unique(links_no_stats$linkid)) {
  map_df <- links_no_stats %>% 
    filter(linkid == link)
  
  map_links_with_stats <- map_links_with_stats %>% 
    addPolylines(data = map_df, lng = ~longitude, lat = ~latitude, color = "red",
                 opacity = 1, label = ~linkid)
}

map_links_with_stats %>% 
  addCircles(data = dir1_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1) %>%
  addCircles(data = dir2_stops, lat = ~stop_lat, lng = ~stop_lon, label = ~ stop_id, radius = 50, opacity = 1)
```

## Links Statistics {.scrollable}

::: panel-tabset
## Data

The travel time of all the links in the same five minute period will be summed, per direction, to give the travel time per the segment

```{r}
links_times <- link_stats %>%
  group_by(logtime, direction) %>%
  summarise(links_time = sum(tt)) %>%
  ungroup() %>%
  mutate(
    day = date(logtime),
    time = as_hms(logtime),
    hour = hour(logtime),
    rush = case_when(
      between(hour, 6, 9) ~ "Morning",
      between(hour, 15, 18) ~ "Evening",
      TRUE ~ "Neither"),
    rush = factor(rush, levels = c("Morning", "Evening", "Neither"))) %>%
  relocate(day:rush, .after = logtime) %>% 
  select(-logtime)

links_times %>%
  names() %>% 
  as_tibble_col("Variable") %>% 
  mutate(Description = c("Date of measurement",
                         "Time of the day in hour:minute:seconds of the measurement",
                         "The hour of the measurement",
                         "Whether the measurement occurrs during rush hour.
                          Morning rush hour occurrs between 6am and 10am,
                          evening rush hour occurrs between 3pm and 7pm,
                          neither otherwise",
                         "The direction of travel",
                         "The total travel time across the segment")) %>% 
  kable() %>% 
  kable_styling()
```

## Plot

```{r}
links_times %>% 
  filter(rush != "Neither") %>%
  ggplot(aes(links_time/60, fill = direction)) +
  geom_density(alpha = 0.4) +
  scale_x_continuous(labels = label_comma(), limits = c(min(links_times$links_time/60),25)) +
  scale_y_continuous(labels = label_comma()) +
  labs(x = "Vehicle Travel Time (Minutes)",
       fill = "Direction",
       title = "Vechile Travel Time Distributions by Rush Hour") +
  facet_wrap(vars(rush)) +
  theme_bw()
```
:::

## Travel Times Comparison

-   General understanding of the relationship

-   Validate data

```{r}
travel_times <- trip_times_agg %>%
  inner_join(links_times) %>% 
  mutate(travel_diff = bus_time - links_time)

travel_times_piv <- travel_times %>% 
  pivot_longer(cols = bus_time:links_time, names_to = "type", values_to = "travel_time") %>% 
  mutate(type = recode(type, bus_time = "Bus", links_time = "Vehicle"))

travel_times_piv %>% 
  filter(rush != "Neither") %>% 
  ggplot(aes(travel_time/60, fill = type)) +
  geom_density(alpha = 0.4) +
  facet_grid(vars(direction), vars(rush)) +
  scale_x_continuous(labels = label_comma(), limits = c(min(travel_times_piv$travel_time/60), 25)) +
  labs(x = "Travel Time (Minutes)", fill = "Type", title = "Bus Travel Time vs Vehicle Travel Time") +
  theme_bw()
```

## Travel Times Calendar

::: panel-tabset
## Northbound

```{r}
travel_times_piv_dir1 <- travel_times_piv %>% 
  filter(direction == directions[1])

travel_times_piv_dir1 %>%  
  ggplot(aes(time, travel_time, color = type)) +
  geom_line(size = 0.75) +
  facet_wrap(vars(day), scales = "free_y") +
  scale_x_time(labels = label_time("%H:%M")) +
  ggtitle(directions[1]) +
  labs(x = "Time",
       y = "Travel Time", 
       color = "Type", 
       title = "Northbound Bus Times vs Vehicle Times") +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    legend.title = element_blank(),
    legend.justification = "bottom",
    legend.position = c(0.5, 0),
    legend.text = element_text(size = 10))
```

## Southbound

```{r}
travel_times_piv_dir2 <- travel_times_piv %>% 
  filter(direction == directions[2])

travel_times_piv_dir2 %>% 
  ggplot(aes(time, travel_time, color = type)) +
  geom_line(size = 0.75) +
  facet_wrap(vars(day), scales = "free_y") +
  scale_x_time(labels = label_time("%H:%M")) +
  ggtitle(directions[2]) +
  labs(x = "Time",
       y = "Travel Time", 
       color = "Type", 
       title = "Southbound Bus Times vs Vehicle Times") +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    legend.title = element_blank(),
    legend.justification = "bottom",
    legend.position = c(0.5, 0),
    legend.text = element_text(size = 10))
```
:::

## Scatter Plot and Correlation

::: panel-tabset
## Plot

```{r}
travel_times %>% 
  ggplot(aes(bus_time/60, links_time/60)) +
  geom_point(alpha = 0.3) +
  scale_x_continuous(labels = label_comma()) +
  scale_y_continuous(labels = label_comma()) +
  labs(x = "Bus Travel Times (Minutes)",
       y = "Vehicles Travel Times (Minutes)",
       title = "Bus Travel Times vs Vehicles Travel Times per Direction") +
  facet_wrap(vars(direction), scales = "free") +
  theme_bw()
```

## Correlation

```{r}
travel_times %>% 
  group_by(direction) %>% 
  summarise(Correlation = round(cor(bus_time, links_time), 2)) %>% 
  rename(Direction = direction) %>% 
  kable() %>% 
  kable_styling()
```
:::

## Average Day Travel Time

```{r}
links_30min <- link_stats %>%
  group_by(logtime, direction) %>%
  summarise(links_time = sum(tt)) %>%
  ungroup() %>% 
  mutate(logtime = ceiling_date(logtime, "30 mins"),
         time = as_hms(logtime)) %>% 
  group_by(time, direction) %>% 
  summarise(links_time = mean(links_time)) %>% 
  ungroup() %>% 
  mutate(rush = case_when(
           between(time, as_hms("06:00:00"), as_hms("10:00:00")) ~ "morning",
           between(time, as_hms("15:00:00"), as_hms("19:00:00")) ~ "evening",
           TRUE ~ "neither"),
         rush = factor(rush, levels = c("morning", "evening", "neither"))) %>% 
  relocate(links_time, .after = everything())

# Average bus trip times in each 30 minute bin
trip_times_30min <- trip_times %>% 
  mutate(arrival_time = ceiling_date(arrival_time, "30 minutes"),
         time = as_hms(arrival_time)) %>% 
  group_by(time, direction) %>% 
  summarise(bus_time = round(mean(trip_time))) %>%
  ungroup() %>% 
  mutate(rush = case_when(
           between(time, as_hms("06:00:00"), as_hms("10:00:00")) ~ "morning",
           between(time, as_hms("15:00:00"), as_hms("19:00:00")) ~ "evening",
           TRUE ~ "neither"),
         rush = factor(rush, levels = c("morning", "evening", "neither"))) %>% 
  relocate(bus_time, .after = everything())

links_trips_30min <- links_30min %>% 
  inner_join(trip_times_30min) %>% 
  pivot_longer(cols = links_time:bus_time, names_to = "type", values_to = "value") %>% 
  mutate(type = recode(type, bus_time = "Bus", links_time = "Vehicle"))

ggplot(links_trips_30min, aes(time, value/60)) +
geom_line(alpha = 0.2) +
geom_line(data = filter(links_trips_30min, rush == "morning"), color = "blue") +
geom_line(data = filter(links_trips_30min, rush == "evening"), color = "blue") +
facet_grid(rows = vars(type), cols = vars(direction)) +
annotate("rect", xmin = as_hms("06:00:00"), xmax = as_hms("10:00:00"), ymin = -Inf, ymax = Inf,
         fill = "red", alpha = .1) +
annotate("rect", xmin = as_hms("15:00:00"), xmax = as_hms("19:00:00"), ymin = -Inf, ymax = Inf,
         fill = "red", alpha = .1) +
scale_x_time(limits = as_hms(c("06:00:00", "23:59:59")),
             breaks = as_hms(c("06:00:00", "08:00:00", "10:00:00", "12:00:00",
                               "15:00:00", "17:00:00", "19:00:00")),
             labels = c("6", "8", "10", "12", "15", "17", "19")) +
scale_y_continuous(labels = label_comma()) +
labs(x = "Time (Hour)",
     y = "Travel Time (Minutes)",
     title = "Average Travel Time Pattern") +
theme_bw()
```
